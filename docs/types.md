# Система типов LiteGQL

Используется строгая динамическая типизация, обеспечивающаяся при помощи проверки типов во время исполнения. Типы
проверяются "в глубину", то есть, например, множество пар чисел и множество пар пар чисел имеют разные типы.

## Типы данных

![Схема типов](https://i.imgur.com/hbq8fA7.png)

### Автоматы

Типы данных, содержащие внутри себя автомат. Поддерживают операции с вершинами и рёбрами, а также операции
комбинирования представимых ими языков. Все вершины автомат должны принадлежать одному типу данных.

`Reg<V>` — регулярное выражение, представленное в виде НКА с вершинами типа `V`.

`String` — строка. Все строки являются автоматами `Reg<Int>` из двух вершин и одного перехода, отличаясь от них лишь
способом вывода в консоль. Любые операции с объектами данного класса кроме вывода в консоль переводят их в `Reg<Int>`.

`Cfg<V>` — контекстно-свободная грамматика, представленная в виде рекурсивного автомата с вершинами типа `V`.

### Вершины

Типы данных, которые могут храниться в вершинах автоматов.

`Int` — целое число. Изначально все созданные автоматы содержат вершины этого типа.

`Pair<L, R>` — пара из двух вершин типов `L` и `R` соответственно. Появляется в вершинах при пересечении автоматов.

### Прочие

Вспомогательные типы данных.

`Bool` — булево значение истины или лжи. Может использоваться для фильтрации множеств.

`Set<T>` — неупорядоченное множество неповторяющихся элементов типа `T`. Пустое множество также является множеством
элементов строго определённого типа.

`Edge<V>` — ребро между двумя вершинами типа `V` с меткой типа `String`.

## Литералы

Объекты некоторых типов данных можно создать при помощи литералов:

- Числа (`0`, `1`, `-100`) создают объекты типа `Int`
- `true` и `false` создают соответствующие объекты типа `Bool`
- Строки в двойных кавычках (`"Hello world!"`) создают объекты типа `String`
- Строки в двойных кавычках с приписанной `r` (`r"(a | b)* c"`) создают объекты типа `Reg<Int>` — интерпретация
происходит [по правилам pyformlang](https://pyformlang.readthedocs.io/en/latest/usage.html#regular-expression)
- Строки в двойных кавычках с приписанной `c` (`c"S -> a S b | epsilon"`) создают объекты типа `Cfg<Int>` —
интерпретация происходит
[по правилам pyformlang](https://pyformlang.readthedocs.io/en/latest/usage.html#context-free-grammar)

## Сопоставление с образцом

Некоторые выражения включают в себя лямбда-функции. Данные функции принимают единственный аргумент и могут динамически
связывать его части с именами переменных. Для этого существуют следующие образцы:

- `_` — принимает часть любого типа и "отбрасывает" её, не связывая с какой-либо переменной
- `имя_переменной` — связывает сопоставляемую часть с указанной переменной
- `(образец, образец)` — раскрывает объект типа `Pair`, сопоставляя его части с указанными под-образцами
- `(образец, образец, образец)` — раскрывает объект типа `Edge`, сопоставляя его части (в порядке начало, метка,
конец) с указанными под-образцами; так как ребро в качестве метки может иметь лишь строку, то средним образцом имеет
смысл указывать лишь `_` или имя переменной

Попытка сопоставления с образцом объекта неподходящего типа приведёт к ошибке сопоставления.

## Функции

### Динамическое создание объектов

`{ }` — создание множества. Пустое множество получает тип `Set<Int>`.
- `() -> Set<Int>`
- `(T, T, ..., T) -> Set<T>`

`( , )` — создание пары вершин.
- `(Int, Int) -> Pair<Int, Int>`
- `(Int, Pair<V>) -> Pair<Int, Pair<V>>`
- `(Pair<V>, Int) -> Pair<Pair<V>, Int>`
- `(Pair<V>, Pair<U>) -> Pair<Pair<V>, Pair<U>>`

`( , , )` — создание ребра с меткой между вершинами.
- `(Int, String, Int) -> Edge<Int>`
- `(Pair<V>, String, Pair<V>) -> Edge<Pair<V>>`

`load` — загрузка автомата, тип которого определяется аргументом.
- `(String) -> Reg<Int>`, если аргумент — путь к существующему файлу, имя которого не начинается на "cfg", или
название графа из датасета CFPQ_Data
- `(String) -> Cfg<Int>`, если аргумент — путь к существующему файлу, имя которого начинается на "cfg"

### Работа с множествами

`in` — проверка на вхождение в множество.
- `(T, Set<T>) -> Bool`

`map` — создание нового множества путём применения лямбда-функции к элементам указанного множества. В случае если
указанное множество пусто, тип лямбда-функции не проверяется, а множество-результат имеет тип `Set<Int>`.
- `((A) -> B, Set<C>) -> Set<Int>`, если множество-аргумент пустое
- `((A) -> B, Set<A>) -> Set<B>`

`filter` — создание нового множества, содержащее лишь те элементы множества-аргумента, для которых лямбда-функция
вернула истинное булево значение.
- `((T) -> Bool, Set<T>) -> Set<T>`

### Изменение автоматов

`add_starts`, `add_finals`, `set_starts`, `set_finals` — добавление или установка стартовых или финальных вершин в
автомат. Для `Cfg` изменения затрагивают только бокс стартовой переменной.
- `(String, Set<Int>) -> Reg<Int>`
- `(Reg<V>, Set<V>) -> Reg<V>`
- `(Cfg<V>, Set<V>) -> Cfg<V>`

`get_starts`, `get_finals`, `get_vertices` — получение стартовых, финальных или всех вершин автомата. Для `Cfg`
стартовые и финальные вершины возвращаются лишь для бокса стартовой переменной.
- `(String) -> Set<Int>`
- `(Reg<V>) -> Set<V>`
- `(Cfg<V>) -> Set<V>`

`get_edges` — получение всех рёбер автомата. Для `Cfg` рёбра, обозначающие рекурсивный вызов бокса переменной `A`,
будут иметь метки `"<var>A"`.
- `(String) -> Set<Edge<Int>>`
- `(Reg<V>) -> Set<Edge<V>>`
- `(Cfg<V>) -> Set<Edge<V>>`

`get_labels` — получение всех меток рёбер автомата. Для `Cfg` рёбра, обозначающие рекурсивный вызов бокса переменной
`A`, будут иметь метки `"<var>A"`.
- `(String) -> Set<String>`
- `(Reg<V>) -> Set<String>`
- `(Cfg<V>) -> Set<String>`

`get_reachables` — получение таких пар стартовых и финальных вершин, что финальная достижима из соответствующей ей
стартовой. Для `Cfg` возвращаются лишь пары из бокса стартовой переменной, однако при построении результата структура
других боксов также учитывается.
- `(String) -> Set<Pair<Int, Int>>`
- `(Reg<V>) -> Set<Pair<V, V>>`
- `(Cfg<V>) -> Set<Pair<V, V>>`

`&` — пересечение автоматов. В вершинах получившегося автомата находятся пары вершин автоматов-аргументов в том
порядке, в котором те были указаны при пересечении.
- `(String, String) -> Reg<Pair<Int, Int>>`
- `(String, Reg<V>) -> Reg<Pair<Int, V>>`
- `(Reg<V>, String) -> Reg<Pair<V, Int>>`
- `(Reg<V>, Reg<U>) -> Reg<Pair<V, U>>`
- `(String, Cfg<V>) -> Cfg<Pair<Int, V>>`
- `(Cfg<V>, String) -> Cfg<Pair<V, Int>>`
- `(Reg<V>, Cfg<U>) -> Cfg<Pair<V, U>>`
- `(Cfg<V>, Reg<U>) -> Cfg<Pair<V, U>>`

`.`, `|` — конкатенация или объединение автоматов.
- `(String, String) -> Reg<Int>`
- `(String, Reg<Int>) -> Reg<Int>`
- `(Reg<Int>, String) -> Reg<Int>`
- `(Reg<V>, Reg<V>) -> Reg<V>`
- `(String, Cfg<Int>) -> Cfg<Int>`
- `(Cfg<Int>, String) -> Cfg<Int>`
- `(Reg<V>, Cfg<V>) -> Cfg<V>`
- `(Cfg<V>, Reg<V>) -> Cfg<V>`
- `(Cfg<V>, Cfg<V>) -> Cfg<V>`

`*` — звезда Клини для автомата.
- `(String) -> Reg<Int>`
- `(Reg<V>) -> Reg<V>`
- `(Cfg<V>) -> Cfg<V>`

## Инструкции

Инструкции вывода в консоль (`print`) и связывания (`=`) принимают выражения любых
типов.
