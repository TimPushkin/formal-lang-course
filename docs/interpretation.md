# Интерпретатор LiteGQL

Для запуска интерпретатор LiteGQL необходимо
[сгенерировать синтаксический анализатор](../project/litegql/grammar/README.md), а затем выполнить следующую команду:

```shell
# Находясь в корне проекта
python -m project путь/к/файлу/с/кодом
```

В случае успешного исполнения в консоль будет напечатан результат, а код возврата будет равен 0. В случае ошибки она
также будет выведена в консоль, а код возврата будет ненулевым.

## Загрузка графов и грамматик

В LiteGQL предусмотрена возможность задавать регулярные выражения и контекстно-свободные грамматики при помощи литералов
(подробнее об этом рассказывается в [описании системы типов](types.md)), однако помимо этого их можно загружать из
файлов, а графы также и из датасета CFPQ_Data.

Для этого используется функция `load`. Если её аргумент — путь к существующему в системе файлу, то будет произведено
его чтение (если название файла начинается с "cfg", то будет произведена попытка считать КС-грамматику, иначе — граф),
иначе будет произведён поиск графа с заданным названием в датасете. Для графов все вершины становятся стартовыми и
финальными, а для КС-грамматики эти свойства можно дополнительно указать.

### Формат файла с описанием графа

Формат файла с графом — DOT с `digraph`, где вершины — числа, а метки рёбер — строки, указанные в `label` (если
метки не указано, то ей станет пустая строка). При чтении графа из файла или загрузке из датасета все его вершины
становятся стартовыми и финальными.

Пример DOT-файла с графом, содержащим два цикла с метками "a" и "b":
```
digraph {
  0 -> 1 -> 2 -> 0 [label=a]
  2 -> 3 -> 2 [label=b]
}
```

### Формат файла с описанием КС-грамматики

Формат файла с КС-грамматикой — DOT с `digraph`, интерпретируемый как рекурсивный автомат. Название основного графа
становится стартовой переменной, названия подграфов — переменными боксов. Каждый подграф интерпретируется как бокс для
соответствующей переменной по правилам считывания графа. Метка считается переменной, если она начинается с большой
буквы, иначе она считается терминалом (таким образом, отсутствующая метка интерпретируется как терминал из пустой
строки). Вершина становится стартовой и финальной, если для неё не указано `is_start=False` или `is_final=False`.

Пример DOT-файла, описывающего грамматику с правилами `S -> a S b | AB` и `AB -> a b`:
```
digraph S {
  subgraph S {
    1 [is_final=False]
    2 [is_start=False, is_final=False]
    3 [is_start=False, is_final=False]
    4 [is_start=False]
    1 -> 2 [label=a]
    2 -> 3 [label=S]
    3 -> 4 [label=b]
    1 -> 4 [label=AB]
  }
  subgraph AB {
    5 [is_final=False]
    6 [is_start=False, is_final=False]
    7 [is_start=False]
    5 -> 6 [label=a]
    6 -> 7 [label=b]
  }
}
```

## Использованные алгоритмы

В интерпретаторе для нахождения достижимых вершин в конечных и рекурсивных автоматах используется **построение
транзитивного замыкания путём возведения в степень матрицы смежности автоматов** как уже реализованный и
протестированный ранее метод.

Для пересечения конечных автоматов с рекурсивными используется **тензорный алгоритм CFPQ** как единственный из ранее
реализованных CFPQ-алгоритмов, не требующий предоставления КС-грамматики в явном виде.

## Особенности реализации

### Области видимости переменных

В LiteGQL помимо глобальной области видимости, где переменные создаются инструкцией связывания, существуют локальные
области видимости лямбда-функций. Данные области видимости "перекрывают" друг друга: сначала тело лямбда-функции
обращается к своей области видимости, затем — к внешней области видимости, которая может быть как глобальной, так и
локальной для объемлющей лямбда-функции. Значения локальных областей видимости не перезаписывают глобальные значения,
"исчезая" из памяти, как только заканчивается исполнение тела соответствующей лямбда-функции.

### Неизменяемость значений

Все операции создают новые значения вместо изменения существующих. Например, изменение стартовых вершин в сохранённом
автомате создаёт новую копию данного автомата с изменёнными стартовыми вершинами. Это стоит учитывать при работе с
большими графами.

### "Склеивание" одинаковых вершин при комбинировании автоматов

При реализации методов комбинирования автоматов (пересечение, объединение, конкатенация, звезда Клини) в интерпретаторе
был сделан упор на сохранение ("не изменение") информации в вершинах, из-за чего при данных операциях новые вершины не
создаются, а существующие не изменяются (лишь при пересечении создаются пары уже существующих вершин).

По этой причине стоит помнить, что вершины с одинаковым содержимым интерпретируются как одинаковые. Например, при
объединении двух автоматов, каждый из которых имеет вершину с числом `1`, данные вершины "склеятся" в одну в итоговом
автомате.

Стоит отметить, что с переменными в грамматиках такого не произойдёт, так как их интерпретатор по мере необходимости
изменяет свободно.

### Достижимость вершин

При нахождении достижимых вершин в ответ вносятся те, что указаны в автомате как стартовые или финальные соответственно.
При этом, если вершина является и стартовой, и финальной, она считается достижимой из самой себя.
